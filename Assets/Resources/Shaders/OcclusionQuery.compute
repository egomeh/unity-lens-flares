#pragma kernel OcclusionQuery
#pragma kernel OcclusionQueryDebug

#include "UnityCG.cginc"

static const float PI = 3.14159265f;

CBUFFER_START(Params)
    float4 _LightPosition; // x, y: light in 0-1 UV coordinates, z: light depth
    float4 _SamplingParams; // x: sampling radius in UV space, y: number of samples in each dimension, z: Offset in visibility buffer
    float4 _DepthTextureDimensions; // x: width, y: height, z: width / height
    float4 _DepthbufferSampleOffset; // xy: depth sampling scale, zw: depth sampling offset
    float4 _ValidAreaScreenSpace; // a defined box on screen. If the occlusion query samples outside the box, the samples are discarded
CBUFFER_END

Texture2D<float> _CameraDepthTexture : register(t0);
SamplerState sampler_CameraDepthTexture;

RWStructuredBuffer<uint> _Visibility : register(u0);

RWTexture2D<float4> _DebugTexture  : register(u1);

uint3 QueryVisibility(uint2 threadPosition, out uint2 samplingPosition)
{
    const float2 aspectCorrection = float2(1., _DepthTextureDimensions.z);

    float2 lightTexcoord = _LightPosition.xy * .5 + .5;

    uint2 lightTexturePosition = lightTexcoord * _DepthTextureDimensions.xy;
    samplingPosition = lightTexturePosition + threadPosition - _SamplingParams.y / 2u;

    float2 sampleTexcoord = float2(samplingPosition) / _DepthTextureDimensions.xy;

    uint inSampleDisk = step(length((sampleTexcoord - lightTexcoord) / aspectCorrection), _SamplingParams.x);

    float2 onScreenXY = step(_ValidAreaScreenSpace.xy, sampleTexcoord) - step(_ValidAreaScreenSpace.zw, sampleTexcoord);
    uint onScreen = onScreenXY.x * onScreenXY.y;

    float depth = _CameraDepthTexture[samplingPosition * _DepthbufferSampleOffset.xy + _DepthbufferSampleOffset.zw];
    uint visible = step(depth, _LightPosition.z) * onScreen;

    return uint3(inSampleDisk, onScreen, visible);
}

[numthreads(8, 8, 1)]
void OcclusionQuery(uint2 dispatchThreadId : SV_DispatchThreadID, uint2 groupThreadId : SV_GroupThreadID)
{
    const uint2 threadPosition = dispatchThreadId;

    uint2 samplingPosition;

    uint3 visibility = QueryVisibility(threadPosition, samplingPosition);

    uint inSampleDisk = visibility.x;
    uint onScreen = visibility.y;
    uint visible = visibility.z;

    uint visibilityBufferOffset = _SamplingParams.z;

    // Write whether the pixel is visible
    InterlockedAdd(_Visibility[visibilityBufferOffset], visible * inSampleDisk);

    // Increment counter if the pixel is within sampling radius
    InterlockedAdd(_Visibility[visibilityBufferOffset + 1u], inSampleDisk);
}

[numthreads(8, 8, 1)]
void OcclusionQueryDebug(uint2 dispatchThreadId : SV_DispatchThreadID, uint2 groupThreadId : SV_GroupThreadID)
{
    const uint2 threadPosition = dispatchThreadId;

    uint2 samplingPosition;

    uint3 visibility = QueryVisibility(threadPosition, samplingPosition);

    uint inSampleDisk = visibility.x;
    uint onScreen = visibility.y;
    uint visible = visibility.z;

    uint visibilityBufferOffset = _SamplingParams.z;

    if (onScreen != 0)
    {
        _DebugTexture[samplingPosition] = float4(1. - inSampleDisk, inSampleDisk * visible, inSampleDisk * (1. - visible), 1.) * .5;
    }

    // Write whether the pixel is visible
    InterlockedAdd(_Visibility[visibilityBufferOffset], visible * inSampleDisk);

    // Increment counter if the pixel is within sampling radius
    InterlockedAdd(_Visibility[visibilityBufferOffset + 1u], inSampleDisk);
}
