#pragma kernel OcclusionQuery

#include "UnityCG.cginc"

static const float PI = 3.14159265f;

CBUFFER_START(Params)
    float4 _LightPosition; // x, y: light in 0-1 UV coordinates, z: light depth
    float4 _SamplingParams; // x: depth threshold, y: sample radius, z: number of samples in each dimension
    float4 _DepthTextureDimensions; // x: width, y: height, z: width / height
CBUFFER_END

Texture2D<float> _CameraDepthTexture : register(t0);
SamplerState sampler_CameraDepthTexture;

RWStructuredBuffer<uint> _Visibility : register(u0);
// RWTexture2D<float4> _DebugTexture : register(u1);

[numthreads(8, 8, 1)]
void OcclusionQuery(uint2 dispatchThreadId : SV_DispatchThreadID, uint2 groupThreadId : SV_GroupThreadID)
{
    const uint2 threadPosition = dispatchThreadId;

    const float2 aspectCorrection = float2(1., _DepthTextureDimensions.z);

    float2 lightTexcoord = _LightPosition.xy * .5 + .5;

    uint2 lightTexturePosition = lightTexcoord * _DepthTextureDimensions.xy;
    uint2 samplingPosition = lightTexturePosition + threadPosition - _SamplingParams.y / 2u;

    float2 sampleTexcoord = float2(samplingPosition) / _DepthTextureDimensions.xy;

    uint inSampleDisk = step(length((sampleTexcoord - lightTexcoord) / aspectCorrection), _SamplingParams.x);

    float depth = _CameraDepthTexture[samplingPosition];
    uint visible = step(depth, _LightPosition.z);

    // _DebugTexture[samplingPosition] = lerp(float4(1. - visible, visible, 0., 1.), float4(0., 0., 1., 1.), 1. - inSampleDisk);

    // Write whether the pixel is visible
    InterlockedAdd(_Visibility[0u], visible * inSampleDisk);

    // Increment counter if the pixel is significant
    InterlockedAdd(_Visibility[1u], inSampleDisk);
}
